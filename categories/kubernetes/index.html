<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes | 🏔️ MLOps Journey</title>
<meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://keonhoban.github.io/mlops-journey/categories/kubernetes/><link crossorigin=anonymous href=/mlops-journey/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://keonhoban.github.io/mlops-journey/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://keonhoban.github.io/mlops-journey/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://keonhoban.github.io/mlops-journey/favicon-32x32.png><link rel=apple-touch-icon href=https://keonhoban.github.io/mlops-journey/apple-touch-icon.png><link rel=mask-icon href=https://keonhoban.github.io/mlops-journey/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://keonhoban.github.io/mlops-journey/categories/kubernetes/index.xml><link rel=alternate hreflang=en href=https://keonhoban.github.io/mlops-journey/categories/kubernetes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://keonhoban.github.io/mlops-journey/categories/kubernetes/"><meta property="og:site_name" content="🏔️  MLOps Journey"><meta property="og:title" content="Kubernetes"><meta property="og:locale" content="ko"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://keonhoban.github.io/mlops-journey/ accesskey=h title="🏔️  MLOps Journey (Alt + H)">🏔️ MLOps Journey</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://keonhoban.github.io/mlops-journey/ title="🏠 Home"><span>🏠 Home</span></a></li><li><a href=https://keonhoban.github.io/mlops-journey/projects/ title="📂 Projects"><span>📂 Projects</span></a></li><li><a href=https://keonhoban.github.io/mlops-journey/posts/ title="📝 Blog"><span>📝 Blog</span></a></li><li><a href=https://keonhoban.github.io/mlops-journey/about/ title="🧗 About"><span>🧗 About</span></a></li><li><a href=https://keonhoban.github.io/mlops-journey/categories/ title="📖 Categories"><span>📖 Categories</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://keonhoban.github.io/mlops-journey/>Home</a>&nbsp;»&nbsp;<a href=https://keonhoban.github.io/mlops-journey/categories/>Categories</a></div><h1>Kubernetes</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[MLOps 플랫폼 구축 : Airflow-MLflow-FastAPI (Helm)]</h2></header><div class=entry-content><p>🧩 실전 시나리오 기반 구성 배경 이 프로젝트는 단순 실습을 넘어서, 실제 발생하는 다음과 같은 문제들을 해결하기 위한 MLOps 인프라 구축을 목표로 설계되었습니다.
여러 모델 실험 결과가 뒤섞여 추적이 어려운 문제
→ MLflow Tracking 서버 + PostgreSQL 메타데이터 저장소 구성
모델 파일 및 로그가 로컬에만 저장되어 협업 및 재현성이 떨어지는 문제
→ S3 기반 artifact store 구성 + pyfunc 기반 모델 서빙 구조 설계
수작업 DAG 등록, 모델 배포 등의 비효율적 운영 문제
→ Airflow + GitSync 연동으로 파이프라인 자동화 및 버전 관리 가능
...</p></div><footer class=entry-footer><span title='2025-07-15 17:55:05 +0900 +0900'>July 15, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to [MLOps 플랫폼 구축 : Airflow-MLflow-FastAPI (Helm)]" href=https://keonhoban.github.io/mlops-journey/projects/mlops_pipeline/helm/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[MLOps 플랫폼 구축 - 6단계: 실시간 모델 핫스왑 구조 실험]</h2></header><div class=entry-content><p>🧠 시나리오 설명 머신러닝 모델을 실서비스에 배포할 때, 기존 모델을 새 모델로 안전하게 교체(hot-swap)하는 자동화 구조는 매우 중요한 요구사항입니다.
✅ TL;DR Airflow에서 학습 스크립트를 실행하고 조건부로 모델 등록 성능 기준을 충족한 모델은 Staging으로 자동 승격 FastAPI는 /reload 요청 시 Staging 모델을 다시 로딩 → 코드 수정 없이 핫스왑 운영 환경에서의 실험 자동화, 모델 A/B 테스트, 모델 롤백 등에 확장 가능하도록 설계 🧠 구조 다이어그램 (핫스왑 흐름) 🧩 핵심 구성 요소 1. Airflow DAG - 조건부 모델 등록 # dags/dag_ml_experiment.py from airflow import DAG from airflow.operators.python import PythonOperator, BranchPythonOperator from airflow.operators.empty import EmptyOperator from airflow.models import Variable from datetime import datetime, timedelta, timezone import sys sys.path.append('/opt/airflow/dags/repo/ml_code') from train_and_log_model_fastapi import train_model default_args = { 'start_date': datetime.now(timezone.utc) - timedelta(days=1) } def run_and_check(): # Variable로 파라미터 동적 제어 try: C = float(Variable.get("logreg_C", default_var=1.0)) max_iter = int(Variable.get("logreg_max_iter", default_var=200)) except Exception as e: print(f"[ERROR] 파라미터 불러오기 실패: {str(e)}. 기본값 사용.") C, max_iter = 1.0, 200 # 정확도 기준으로 성공/실패 분기 acc = train_model(C=C, max_iter=max_iter) if acc > 0.9: return 'notify_success' else: return 'notify_failure' def notify_success(): print("🎉 모델 등록 및 핫스왑 성공! FastAPI에 최신 모델 반영 완료.") def notify_failure(): print("❌ 성능 기준 미달. 모델 등록/서빙 생략됨.") with DAG( dag_id="mlflow_experiment_conditional_register_runner_fastapi", default_args=default_args, schedule=None, catchup=False, ) as dag: branch_task = BranchPythonOperator( task_id='branch_by_accuracy', python_callable=run_and_check ) success_notify_task = PythonOperator( task_id='notify_success', python_callable=notify_success ) failure_notify_task = PythonOperator( task_id='notify_failure', python_callable=notify_failure ) branch_task >> [success_notify_task, failure_notify_task] 2. 모델 학습 및 등록 # ml_code/train_and_log_model_fastapi.py import mlflow import mlflow.sklearn from mlflow.tracking import MlflowClient from sklearn.datasets import load_iris from sklearn.linear_model import LogisticRegression from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score import sys import requests import time mlflow.set_tracking_uri("http://mlflow-service.mlflow.svc.cluster.local:5000") mlflow.set_experiment("train_and_register_model_exp") def train_model(C, max_iter): X, y = load_iris(return_X_y=True) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) with mlflow.start_run() as run: clf = LogisticRegression(C=C, max_iter=max_iter) clf.fit(X_train, y_train) y_pred = clf.predict(X_test) acc = accuracy_score(y_test, y_pred) mlflow.log_param("C", C) mlflow.log_param("max_iter", max_iter) mlflow.log_metric("accuracy", acc) mlflow.sklearn.log_model(clf, "model") print(f"[INFO] Logged model with accuracy={acc}") if acc > 0.9: # 모델 등록 result = mlflow.register_model( model_uri=f"runs:/{run.info.run_id}/model", name="best_model" ) version = result.version print(f"[INFO] ✅ 모델 등록 완료 (version={version})") # 등록 직후 DB 업데이트 시간 필요 time.sleep(3) # 스테이지 승격 + 기존 버전 Archive client = MlflowClient() client.transition_model_version_stage( name="best_model", version=version, stage="Staging", archive_existing_versions=False # 스테이징은 여러 개 가능 ) print(f"[INFO] 🚀 모델 version {version} → Staging 반영 완료") # FastAPI 핫스왑 요청 (reload 호출) try: response = requests.post("http://fastapi.local/reload") print(f"[INFO] 🔁 FastAPI 모델 리로드 요청 결과: {response.status_code} {response.text}") except Exception as e: print(f"[ERROR] ❌ FastAPI 리로드 요청 실패: {str(e)}") else: print("[WARN] ❌ 성능 기준 미달 (accuracy &lt;= 0.9)") # 모델 버전 출력 (전후 비교 가능) client = MlflowClient() versions = client.get_latest_versions("best_model", stages=["None", "Staging", "Production"]) for v in versions: print(f"[INFO] 🔄 모델 Version={v.version}, Stage={v.current_stage}") return acc if __name__ == "__main__": acc = train_model(float(sys.argv[1]), int(sys.argv[2])) 3. FastAPI 모델 재로딩 구조 # FastAPI app/main.py from fastapi import FastAPI, Request import mlflow.pyfunc import mlflow from mlflow.tracking import MlflowClient import os app = FastAPI() model = None model_info = {} def load_model_from_mlflow(): global model, model_info tracking_uri = os.environ.get("MLFLOW_TRACKING_URI") model_name = os.environ.get("MODEL_NAME") model_stage = os.environ.get("MODEL_STAGE", "Staging") mlflow.set_tracking_uri(tracking_uri) model_uri = f"models:/{model_name}/{model_stage}" model = mlflow.pyfunc.load_model(model_uri) client = MlflowClient() latest = client.get_latest_versions(name=model_name, stages=[model_stage])[0] run_id = latest.run_id version = latest.version print(f"✅ Reloaded model: name={model_name}, stage={model_stage}, version={version}, run_id={run_id}") model_info = { "model_name": model_name, "stage": model_stage, "version": version, "run_id": run_id, "model_uri": model_uri, } @app.on_event("startup") def startup_event(): load_model_from_mlflow() @app.get("/") def root(): return {"message": "FastAPI MLOps is running!"} # 현재 모델 확인 가능 @app.get("/model-info") def get_model_info(): return model_info @app.post("/predict") async def predict(request: Request): input_data = await request.json() prediction = model.predict(input_data) return {"prediction": prediction.tolist()} # Staging 모델 다시 로드 @app.post("/reload") def reload_model(): try: load_model_from_mlflow() return {"status": "success", "message": "🔁 Model reloaded successfully."} except Exception as e: return {"status": "error", "message": f"Reload failed: {str(e)}"} ✅ 테스트 결과 요약 logreg_C, logreg_max_iter 파라미터로 학습 DAG 설정 가능 모델 등록 시 Staging으로 자동 승격 FastAPI 서버에 /reload 호출 시 핫스왑 적용됨 /model-info, /predict에서 새로운 모델 정보 및 예측 결과 확인 완료 🎓 테스트 검증 (모델 등록 + 핫스왑 확인) # 기존 모델 버전 확인 curl http://fastapi.local/model-info | jq % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 144 100 144 0 0 19251 0 --:--:-- --:--:-- --:--:-- 20571 { "model_name": "best_model", "stage": "Staging", "version": "1", "run_id": "8bd09505eabf40648337e811110ab22c", "model_uri": "models:/best_model/Staging" } # 예측 결과 확인 curl -X POST http://fastapi.local/predict \ -H "Content-Type: application/json" \ -d '[ [5.1, 3.5, 1.4, 0.2] ]' | jq % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 42 100 18 100 24 311 415 --:--:-- --:--:-- --:--:-- 736 { "prediction": [ 0 ] } # 모델 reload (핫스왑) curl -X POST http://fastapi.local/reload | jq % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 66 100 66 0 0 186 0 --:--:-- --:--:-- --:--:-- 186 { "status": "success", "message": "🔁 Model reloaded successfully." } # 신규 모델 버전 확인 curl http://fastapi.local/model-info | jq % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 144 100 144 0 0 42985 0 --:--:-- --:--:-- --:--:-- 48000 { "model_name": "best_model", "stage": "Staging", "version": "2", "run_id": "72f388927f5749c185b828a1a16bb063", "model_uri": "models:/best_model/Staging" } # 예측 결과 확인 curl -X POST http://fastapi.local/predict \ -H "Content-Type: application/json" \ -d '[ [5.1, 3.5, 1.4, 0.2] ]' | jq % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 42 100 18 100 24 3831 5108 --:--:-- --:--:-- --:--:-- 10500 { "prediction": [ 0 ] }</p></div><footer class=entry-footer><span title='2025-07-10 17:12:00 +0900 +0900'>July 10, 2025</span>&nbsp;·&nbsp;5 min</footer><a class=entry-link aria-label="post link to [MLOps 플랫폼 구축 - 6단계: 실시간 모델 핫스왑 구조 실험]" href=https://keonhoban.github.io/mlops-journey/posts/mlops-pipeline-helm/06/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[MLOps 플랫폼 구축 - 5단계: FastAPI 서빙: MLflow 모델 연동 및 핫스왑 구조 구축]</h2></header><div class=entry-content><p>🧠 시나리오 설명 “ 모델을 수동으로 넣는 것이 아니라,
MLflow에 등록된 Staging 모델을 서빙 API에서 자동 로딩하는 구조를 지향합니다.”
FastAPI는 경량화된 서빙 서버로서 적합 MLflow pyfunc.load_model()을 통해 자동 로딩 → CI/CD 및 모델 자동화 가능 S3와 연결되므로, “로컬 복사본 관리 X”, 재현성 유지 API 호출을 통해 실제 추론 결과 확인 가능 ✨ TL;DR MLflow에서 등록한 모델을 FastAPI 기반 REST API로 서빙합니다. mlflow.pyfunc.load_model()을 통해 Stage별 버전 관리, 핫스왑, 모델 정보 조회가 가능합니다. 쿠버네티스 기반으로 Helm Chart 배포 + AWS 인증 Secret + Ingress 접근까지 연동합니다. 📐 아키텍처 구성도 ...</p></div><footer class=entry-footer><span title='2025-07-07 17:11:55 +0900 +0900'>July 7, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to [MLOps 플랫폼 구축 - 5단계: FastAPI 서빙: MLflow 모델 연동 및 핫스왑 구조 구축]" href=https://keonhoban.github.io/mlops-journey/posts/mlops-pipeline-helm/05/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[MLOps 플랫폼 구축 - 4단계: Airflow : GitSync + 외부 PostgreSQL + Secret 연동]</h2></header><div class=entry-content><p>🧠 시나리오 설명 “실무에서는 데이터 파이프라인이나 모델 학습 작업을 수시로 업데이트하게 되며,
이를 수동으로 업로드하지 않고 Git 기반으로 관리하는 것이 필수입니다.
Airflow는 GitSync 기능을 통해 DAG를 자동 동기화할 수 있습니다.”
DAG 코드가 Git으로 관리되어야 리뷰, 히스토리, 협업 가능 GitSync → DAG 자동 배포 (CI/CD 개념 적용) Secret으로 Git 인증 → 조직 내 GitOps 문화와 연계 ✨ TL;DR Helm을 통해 Airflow를 배포하면서 DAG 코드를 Git 저장소에서 자동으로 동기화하는 구조 설계 GitSync, Secret 기반 SSH 인증, 외부 PostgreSQL, AWS S3 연동까지 포함해 구성 UI 접근은 Ingress를 통해 이루어지며, 로그는 PVC 또는 S3로 설정 가능 📐 아키텍처 구성도 ...</p></div><footer class=entry-footer><span title='2025-07-03 17:11:53 +0900 +0900'>July 3, 2025</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to [MLOps 플랫폼 구축 - 4단계: Airflow : GitSync + 외부 PostgreSQL + Secret 연동]" href=https://keonhoban.github.io/mlops-journey/posts/mlops-pipeline-helm/04/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[MLOps 플랫폼 구축 - 3단계: MLflow : PostgreSQL + S3 연동 기반 Helm 구성]</h2></header><div class=entry-content><p>🧠 시나리오 설명 “MLflow Tracking 서버는 단순 모델 학습이 아닌 모델의 실험 이력, 하이퍼파라미터, 성능 지표 등을 추적하는 역할을 합니다.
따라서 단일 머신/로컬 환경이 아닌, 서버 기반 Tracking 환경이 필요합니다.”
한 프로젝트에 여러 버전의 모델이 등장하고,
각각 어떤 실험으로부터 나왔는지 **‘회고 가능한 로그’**가 필요함
MLflow Tracking Server + PostgreSQL → 모델 실험 로그 저장
S3 연동 → 모델 파일 저장 위치 분리 (서빙, 재사용 대비)
✨ TL;DR MLflow를 도입시 PostgreSQL, S3, 인증 정보 주입, Helm 배포, Ingress 연동 등 설계 MLflow를 Helm으로 배포하면서 고려한 항목(보안, 아티팩트 저장소, UI 접근 등) 구성 커스텀 Docker 이미지로 psycopg2 설치, Helm chart 구성, Secret 연결까지 포함 📐 아키텍처 구성도 (with Secret & 연동 흐름) ...</p></div><footer class=entry-footer><span title='2025-06-30 17:11:51 +0900 +0900'>June 30, 2025</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to [MLOps 플랫폼 구축 - 3단계: MLflow : PostgreSQL + S3 연동 기반 Helm 구성]" href=https://keonhoban.github.io/mlops-journey/posts/mlops-pipeline-helm/03/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[MLOps 플랫폼 구축 - 2단계: S3 & PostgreSQL 연동을 위한 구성 및 Secret 관리 전략]</h2></header><div class=entry-content><p>🧠 시나리오 설명 “모든 구성 요소가 외부 DB, GitHub, S3 등 민감한 리소스와 연동되기 때문에,
API 키 및 비밀번호를 직접 넣는 건 보안상 위험합니다.
따라서 Kubernetes Secret을 활용해 민감한 정보 노출을 최소화합니다.”
GitSync용 SSH Key를 Secret으로 주입 → GitHub 인증 Airflow DAG 내에서 DB 접속을 위한 커넥션 정보도 Secret 처리 ✨ TL;DR 외부 리소스(AWS S3, DB 등)와 연결할 때, 인증 정보를 직접 코드나 YAML에 노출하는 건 보안상 위험 Kubernetes에서는 Secret과 ConfigMap, 그리고 envFrom, volumeMount 방식을 조합하여 사용 가능 이번 포스팅에서는 MLflow, Airflow, FastAPI와 AWS S3 & PostgreSQL을 연동할 때 사용한 Secret 구성 전략과 마주친 이슈 및 해결책 공유 🧱 아키텍처 구성도 ...</p></div><footer class=entry-footer><span title='2025-06-26 17:11:49 +0900 +0900'>June 26, 2025</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to [MLOps 플랫폼 구축 - 2단계: S3 & PostgreSQL 연동을 위한 구성 및 Secret 관리 전략]" href=https://keonhoban.github.io/mlops-journey/posts/mlops-pipeline-helm/02/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[MLOps 플랫폼 구축 - 1단계: 인프라 설계 및 환경 준비]</h2></header><div class=entry-content><p>🧠 시나리오 설명 “ML 모델을 실험하고 추적하려면 단순 Jupyter Notebook으론 부족합니다.
Kubernetes 기반의 인프라를 선택한 이유는 다음과 같습니다.”
Kubernetes:
👉 ML 모델 학습 및 서빙이 점점 컨테이너 기반으로 이뤄지고 있으며,
자원 할당, 스케일링, 리소스 격리를 위한 플랫폼으로 사실상 표준이 되었음
NFS 구성:
👉 MLflow UI 내의 로그, 메타데이터 등 파일 기반 공유 스토리지 필요,
로컬 볼륨은 Pod가 재시작되거나 이동하면 휘발되므로,
여러 Pod 간 공유가 가능한 파일 스토리지가 필수
(※ 실무에서는 AWS EFS, GCP Filestore 등을 대체로 사용)
...</p></div><footer class=entry-footer><span title='2025-06-23 17:11:47 +0900 +0900'>June 23, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to [MLOps 플랫폼 구축 - 1단계: 인프라 설계 및 환경 준비]" href=https://keonhoban.github.io/mlops-journey/posts/mlops-pipeline-helm/01/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Kubernetes - 5단계: Prometheus + Grafana 모니터링]</h2></header><div class=entry-content><p>목표
쿠버네티스 클러스터 내 자원(Pod, Node 등) 실시간 모니터링 Prometheus로 메트릭 수집 → Grafana 대시보드 시각화 실무 MLOps 환경에서 모니터링 아키텍처 구축 기반 다지기 👉 실습 코드: 🔗 GitHub (Monitoring)
🧭 전체 흐름 요약 ① Helm 저장소 추가 ② Prometheus 설치 (메트릭 수집) ③ Grafana 설치 (대시보드 시각화) ④ Web UI 접속 → Prometheus 연결 → 대시보드 불러오기 📂 디렉토리 구성 k8s-monitoring/ ├── values-prometheus.yaml # Prometheus 커스터마이징 설정 ├── values-grafana.yaml # Grafana 설정 + 비밀번호 지정 ├── README.md ⚙️ [1단계] Helm 저장소 추가 helm repo add prometheus-community https://prometheus-community.github.io/helm-charts helm repo add grafana https://grafana.github.io/helm-charts helm repo update 📦 [2단계] Prometheus 설치 🔹 기본 설치 helm install prometheus prometheus-community/prometheus kubectl port-forward svc/prometheus-server 9090:80 접속: http://localhost:9090
...</p></div><footer class=entry-footer><span title='2025-06-05 20:06:43 +0900 +0900'>June 5, 2025</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to [Kubernetes - 5단계: Prometheus + Grafana 모니터링]" href=https://keonhoban.github.io/mlops-journey/posts/kubernetes/05/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Kubernetes - 4단계: Helm]</h2></header><div class=entry-content><p>목표
Helm CLI 설치 및 Chart 개념 이해 Nginx를 Helm으로 배포 & 기존 YAML 방식과 차이 체감 values.yaml로 설정을 바꾸고 재배포하는 방법 익히기 👉 실습 코드는 🔗 GitHub (Helm)
🧭 전체 흐름 요약 ① Helm 설치 및 Chart 저장소 등록 ② bitnami/nginx Chart 검색 → 설치 ③ 기본 설치 결과 확인 (LoadBalancer → Pending) ④ values.yaml로 NodePort 설정 변경 ⑤ 설정 적용하여 재설치 + 포트 접속 확인 📁 실습 디렉토리 구성 k8s-helm/ ├── values-nginx.yaml # 커스터마이징용 설정 파일 └── README.md ⚙️ [1단계] Helm 설치 🔧 Ubuntu 설치 명령어 curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash helm version 📦 [2단계] Chart 저장소 등록 & 검색 helm repo add bitnami https://charts.bitnami.com/bitnami helm repo update helm search repo nginx helm search repo는 Chart 목록을 검색하는 명령어
...</p></div><footer class=entry-footer><span title='2025-06-05 20:06:41 +0900 +0900'>June 5, 2025</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to [Kubernetes - 4단계: Helm]" href=https://keonhoban.github.io/mlops-journey/posts/kubernetes/04/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[Kubernetes - 3단계 : Ingress & Nginx Controller]</h2></header><div class=entry-content><p>목표
여러 서비스를 도메인 또는 경로 기반으로 라우팅 Cluster 외부에서 서비스를 http://foo.local 형식으로 접근 실무에서 가장 많이 쓰는 Ingress 구조(Nginx Ingress Controller) 익히기 👉 실습 코드는 🔗 GitHub (Ingress_and_Nginx_Controller)
🧭 전체 흐름 요약 ① Ingress Controller 설치 (minikube addons 사용) ② nginx / httpd 서비스 배포 ③ Ingress 리소스로 경로 라우팅 설정 ④ /etc/hosts 수정 → curl 테스트로 확인 📦 실습 디렉토리 구조 k8s-ingress/ ├── deploy-nginx.yaml # nginx 배포 + 서비스 ├── deploy-httpd.yaml # httpd 배포 + 서비스 ├── ingress.yaml # Ingress 라우팅 정의 └── README.md ⚙️ [1단계] Ingress Controller 설치 minikube addons enable ingress kubectl get pods -n ingress-nginx ingress-nginx-controller Pod가 Running 상태면 설치 성공 NodePort 기본 포트: 80, 443 🧱 [2단계] 서비스 2개 배포 (nginx / httpd) 🔹 deploy-nginx.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: nginx-service spec: selector: app: nginx ports: - port: 80 targetPort: 80 🔹 deploy-httpd.yaml apiVersion: apps/v1 kind: Deployment metadata: name: httpd-deployment spec: replicas: 1 selector: matchLabels: app: httpd template: metadata: labels: app: httpd spec: containers: - name: httpd image: httpd ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: httpd-service spec: selector: app: httpd ports: - port: 80 targetPort: 80 🗺️ [3단계] Ingress 라우팅 설정 🔹 ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: example-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: / spec: rules: - host: foo.local http: paths: - path: /nginx pathType: Prefix backend: service: name: nginx-service port: number: 80 - path: /httpd pathType: Prefix backend: service: name: httpd-service port: number: 80 🚀 [4단계] 실행 및 테스트 실습 리소스 적용 kubectl apply -f deploy-nginx.yaml kubectl apply -f deploy-httpd.yaml kubectl apply -f ingress.yaml minikube IP 확인 minikube ip # 예: 192.168.49.2 /etc/hosts 수정 sudo nano /etc/hosts # 아래 줄 추가 192.168.49.2 foo.local curl로 테스트 curl http://foo.local/nginx # nginx 화면 반환 curl http://foo.local/httpd # httpd 페이지 반환 🎯 정리 요약 항목 내용 Ingress HTTP(S) 요청을 Path/Host 기반으로 내부 서비스에 라우팅 Ingress Controller 실제 라우팅 처리 담당 (Nginx 등) /etc/hosts 로컬 DNS 역할 (클러스터 외부 접근 가능하게 설정) 활용 사례 /api, /mlflow, /jupyter 등 URL별 서비스 분리 가능 🧩 실무 팁 Ingress Controller는 단일 진입점 역할 → 도메인 or 경로 기반으로 서비스 분리 가능 실무에서는 TLS 인증서 연동 (Let’s Encrypt, Cert Manager)도 함께 구성 API Gateway 역할로도 확장 가능 (ex. Kong, Ambassador 등) /etc/hosts 설정은 개발 환경 전용 (운영에서는 DNS 서버와 연동) 🔧 MLOps 실전 연결 상황 Ingress 활용 방식 실험 추적 툴 MLflow /mlflow 경로로 노출 노트북 환경 JupyterHub /jupyter 경로로 접속 LLM 서빙 엔드포인트 /v1/chat/completions 등으로 구성 보안 연동 cert-manager + Ingress → TLS 적용</p></div><footer class=entry-footer><span title='2025-06-05 20:06:39 +0900 +0900'>June 5, 2025</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to [Kubernetes - 3단계 : Ingress & Nginx Controller]" href=https://keonhoban.github.io/mlops-journey/posts/kubernetes/03/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://keonhoban.github.io/mlops-journey/categories/kubernetes/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><p style=margin-top:1rem>© 2025 Keonho Ban | <a href=https://github.com/keonhoban target=_blank>GitHub</a> | <a href=mailto:keonho0510@naver.com>Email</a></p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>