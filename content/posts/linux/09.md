+++
date = '2025-04-15T18:44:56+09:00'
draft = false
title = '[리눅스] 9장. 프로세스와 잡 (Process & Job)'
categories = 'Linux'
+++

### 📌 핵심 개념 요약

> 실행 중인 프로그램은 모두 **프로세스(Process)**이며,
> 
> 
> 셸은 이를 **잡(Job)**이라는 단위로 제어한다.
> 

---

### 🧠 결정적 지식 요약

| 개념 | 설명 |
| --- | --- |
| **프로세스** | 실행 중인 프로그램. 고유 PID 가짐 |
| **잡** | 셸이 관리하는 작업 단위. 포그라운드/백그라운드 전환 가능 |
| **시그널** | 프로세스를 제어하는 메시지 (`kill`, `Ctrl+C`, `Ctrl+Z`) |
| **실행 제어** | `&`, `fg`, `bg`, `jobs`, `Ctrl+Z` 등으로 상태 조작 |
| **종료 방식** | `kill -15`: 정상 종료 / `kill -9`: 강제 종료 (주의) |

---

### 🖼️ 실행 흐름 도식

```
[ 실행 흐름 ]

명령 실행
 ↓
프로세스 생성 (PID 부여)
 ↓
 ├─ 포그라운드 실행: 즉시 동작
 ├─ 백그라운드 실행: & / jobs로 확인
 └─ 중단 후 전환: Ctrl+Z → fg / bg

[ 주요 시그널 ]

Ctrl+C   → SIGINT (2): 중단
Ctrl+Z   → SIGTSTP (20): 일시 정지
kill -15 → SIGTERM: 정상 종료
kill -9  → SIGKILL: 강제 종료
```

---

### 🔍 실전 시나리오 연결

| 상황 | 실전 활용 |
| --- | --- |
| **학습 로그 저장 + 백그라운드 실행** | `python train.py > log.txt 2>&1 &` |
| **실행 중 프로세스 확인** | `ps aux` |
| **프로세스 종료** | `kill -15 <PID>` → 응답 없을 시 `kill -9 <PID>` |
| **중단 후 재개** | `Ctrl+Z` → `bg`, `fg` |
| **세션 유지** | `tmux`, `nohup` 등으로 종료 방지 |

---

### 💡 실무 팁 요약

- **PID 확인 루틴**: `ps aux | grep`, `jobs -l`
- **정상 종료 우선**: `kill -15` → `kill -9`은 최후 수단
- **로그 리디렉션 습관화**: `> log 2>&1 &`
- **세션 보존**: `tmux`, `nohup` 필수
- **trap 명령어**: 스크립트 종료 전 cleanup 처리에 활용

---

### 🛠️ MLOps 연결 요약

| 항목 | 예시 |
| --- | --- |
| **학습 세션 유지** | `tmux new -s train1` → SSH 끊겨도 지속 |
| **병렬 학습/실험 실행** | `&`, `tmux`, `screen`으로 동시 실행 |
| **디버깅** | `ps aux`, `kill`, `tail -f`로 상태 추적 |
| **모델 로그 확보** | 학습 시 출력 리디렉션으로 결과 보존 |
| **서버 유지 자동화** | `nohup`, `trap`, 스크립트로 백그라운드 제어 |

---

### ❗ 자주 헷갈리는 포인트

- `kill` = “죽이는 명령” 아님 → **시그널 전달** 도구
- `&`만 사용하면 셸 종료 시 **작업도 함께 종료될 수 있음**
    
    → `tmux`, `nohup`으로 보완
    
- `kill -9`은 프로세스에게 **정리 기회 없이 즉시 종료** → 데이터 손상 위험 있음

---

### 🏁 마무리

> 프로세스와 잡은 리눅스 자동화의 심장이다.
> 
> 
> **제어하고, 추적하고, 보호하는 기술**을 익히면
> 
> MLOps의 안정성과 유연성을 모두 챙길 수 있다.
>
