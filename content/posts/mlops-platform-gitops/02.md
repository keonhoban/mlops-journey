+++
date = '2025-07-22T12:10:21+09:00'
draft = false
title = '[MLOps ìš´ì˜ ê³ ë„í™” - 1ë‹¨ê³„: í•«ìŠ¤ì™‘ ê³ ë„í™” (/reload ë³´ì•ˆÂ·DAG ìë™í™”)]'
categories = ['MLOps Pipeline', 'FastAPI', 'MLflow', 'Airflow', 'Kubernetes', 'Helm']
+++

## í•«ìŠ¤ì™‘ ê³ ë„í™”: `/reload` ë³´ì•ˆ ê°•í™” + DAG ìë™í™” ì—°ë™

---

## ğŸ§  ì‹œë‚˜ë¦¬ì˜¤ ì„¤ëª…

> â€œëª¨ë¸ì„ ì˜ í•™ìŠµì‹œí‚¤ëŠ” ê²ƒë„ ì¤‘ìš”í•˜ì§€ë§Œ,
> 
> 
> ì˜ëª»ëœ ëª¨ë¸ì´ ì‹¤ìˆ˜ë¡œ í•«ìŠ¤ì™‘ë˜ëŠ” ìˆœê°„ì´ ë” ì¹˜ëª…ì ì…ë‹ˆë‹¤.â€
> 
> ê·¸ë˜ì„œ 1ë‹¨ê³„ì—ì„œëŠ” `/reload`ë¥¼ í™•ì‹¤í•˜ê²Œ ì ê·¸ê³ ,
> 
> **í•™ìŠµ â†’ ë“±ë¡ â†’ ê°ì‹œ â†’ í•«ìŠ¤ì™‘**ê¹Œì§€ê°€ Airflowì—ì„œ ìë™ìœ¼ë¡œ í˜ëŸ¬ê°€ë„ë¡ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.
> 
> ì´ ë‹¨ê³„ê°€ ì™„ì„±ë¼ì•¼ ì´í›„ ë‹¨ê³„ì—ì„œ **ì•ˆì „í•œ ìë™ ìš´ì˜(MLOps)**ì„ êµ¬í˜„í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
> 

---

## ğŸ¯ í•µì‹¬ ìš”ì•½

- **ë³´ì•ˆ 3ì¢…**: `x-token`(SealedSecret) + Ingress **IP whitelist** + **TLS**
- **ìë™í™”**: Airflow **Train â†’ Register â†’ Sensor(READY) â†’ Reload** ì „ì²´ ì‹œí€€ìŠ¤
- **ì¼ê´€ì„±**: MLflow **Alias(@A/@B)** ê¸°ë°˜ ë“±ë¡Â·ì¡°íšŒÂ·í•«ìŠ¤ì™‘
- **ê´€ì œ**: ëª¨ë“  ë‹¨ê³„ **ì„±ê³µ/ìŠ¤í‚µ/ì‹¤íŒ¨** Slack ì•Œë¦¼

> í™˜ê²½ ë¶„ë¦¬: dev(*.local) / prod(*.prod) â€” ì˜ˆ: fastapi.local, fastapi.prod
> 

---

## 1ï¸âƒ£ ì•„í‚¤í…ì²˜ í”Œë¡œìš°

```mermaid
sequenceDiagram
    autonumber
    participant AF as Airflow DAG
    participant TM as train_model (í•™ìŠµ)
    participant RG as register_model (ë“±ë¡/alias ì§€ì •)
    participant SN as check_model_ready (READY Sensor)
    participant RL as trigger_reload (FastAPI í˜¸ì¶œ)
    participant IG as Ingress (TLS + IP whitelist)
    participant FA as FastAPI (/variant/{alias}/reload)
    participant MF as MLflow Registry (Alias)
    participant SL as Slack

    AF->>TM: train_model(acc, run_id)
    AF->>AF: check_result(threshold ë¶„ê¸°)
    AF->>RG: register_model(run_id, alias)
    AF->>SN: check_model_ready(model_name, version)
    AF->>RL: trigger_reload(alias, x-token)
    RL->>IG: POST https://fastapi.{env}/variant/{alias}/reload
    IG->>FA: routes/reload.py (x-token ê²€ì¦)
    FA->>MF: Alias(@A/@B) ê¸°ì¤€ ë¡œë”©
    FA-->>RL: {"status":"success", version, run_id}
    AF-->>SL: ë‹¨ê³„ë³„ Slack
    FA-->>SL: í•«ìŠ¤ì™‘ ì„±ê³µ/ì‹¤íŒ¨

```

---

## 2ï¸âƒ£ FastAPI `/reload` ë³´ì•ˆ ë¼ìš°íŠ¸

```python
# charts/fastapi/app/routes/reload.py
import secrets
from fastapi import APIRouter, HTTPException, Header, Request
from core.config import settings
from services.model_loader import load_model_by_alias
from utils.slack_alerts import send_slack_alert

router = APIRouter()

@router.post("/variant/{alias}/reload")
def reload_model(request: Request, alias: str, x_token: str = Header(...)):
    expected = settings.reload_secret_token
    if not expected:
        raise HTTPException(status_code=500, detail="ì„œë²„ ì„¤ì • ì˜¤ë¥˜: ì¸ì¦ í† í° ë¯¸ì„¤ì •")

    if not secrets.compare_digest(x_token, expected):
        raise HTTPException(status_code=403, detail="Access denied")

    loaded = load_model_by_alias(alias)
    if not loaded:
        raise HTTPException(status_code=500, detail="ëª¨ë¸ ë¡œë”© ì‹¤íŒ¨")

    request.app.state.models[alias] = loaded
    info = loaded["info"]
    send_slack_alert(
        f"ğŸ” [FastAPI] ëª¨ë¸ {alias} í•«ìŠ¤ì™‘ ì™„ë£Œ: v{info['version']}, run_id={info['run_id']}"
    )
    return {"status": "success", "variant": alias, "version": info["version"], "run_id": info["run_id"]}
```

---

## 3ï¸âƒ£ Airflow DAG (Train â†’ Register â†’ Sensor â†’ Reload)

```python
# dags/dag_ml_train_register_reload.py
from airflow import DAG
from airflow.operators.python import PythonOperator, BranchPythonOperator
from airflow.sensors.python import PythonSensor
from airflow.utils.trigger_rule import TriggerRule
from airflow.exceptions import AirflowSkipException
from airflow.models import Variable
from datetime import datetime, timedelta
from pendulum import timezone

from ml_code.train_model import train_model
from ml_code.register_model import register_model
from ml_code.rollback_model import rollback_model
from ml_code.trigger_reload import trigger_reload
from ml_code.sensor_model_ready import check_model_ready
from utils.slack_alerts import send_slack_alert, alert_slack
from mlflow.tracking import MlflowClient

kst = timezone("Asia/Seoul")
default_args = {"start_date": datetime(2025, 1, 1, tzinfo=kst), "retries": 1, "retry_delay": timedelta(minutes=2)}

def get_param(key, default, cast, validate=None):
    try:
        val = cast(Variable.get(key, default=str(default)))
        if validate and not validate(val):
            raise ValueError("Validation failed")
        return val
    except Exception as e:
        send_slack_alert(f"[Param] {key} ë¡œë”© ì‹¤íŒ¨: {e} â†’ ê¸°ë³¸ {default} ì‚¬ìš©")
        return default

def get_version_by_alias(model_name, alias):
    try:
        return MlflowClient().get_model_version_by_alias(model_name, alias).version
    except Exception:
        return None

def train_and_evaluate(ti, **_):
    C = get_param("logreg_C", 1.0, float, lambda x: 0.001 <= x <= 10.0)
    max_iter = get_param("logreg_max_iter", 200, int, lambda x: x > 50)
    threshold = get_param("accuracy_threshold", 0.9, float, lambda x: 0.5 <= x <= 0.99)
    model_name = Variable.get("model_name")
    alias = Variable.get("mlflow_alias")
    if not (model_name and alias):
        raise ValueError("í•„ìˆ˜ Variable ëˆ„ë½: model_name ë˜ëŠ” mlflow_alias")

    acc, run_id = train_model(C=C, max_iter=max_iter)
    if not run_id:
        raise ValueError("run_id ì—†ìŒ â†’ í•™ìŠµ ì‹¤íŒ¨")

    for k, v in {"run_id": run_id, "model_name": model_name, "alias": alias, "acc": acc, "threshold": threshold}.items():
        ti.xcom_push(key=k, value=v)

def check_result(ti, **_):
    acc = ti.xcom_pull(task_ids="train_and_evaluate", key="acc")
    thr = ti.xcom_pull(task_ids="train_and_evaluate", key="threshold")
    if acc is None or thr is None:
        send_slack_alert("âŒ check_result â†’ XCom ëˆ„ë½")
        raise AirflowSkipException()
    return "register_model" if acc >= thr else "notify_failure"

def register_model_task(ti, **_):
    run_id = ti.xcom_pull(task_ids="train_and_evaluate", key="run_id")
    model_name = ti.xcom_pull(task_ids="train_and_evaluate", key="model_name")
    alias = ti.xcom_pull(task_ids="train_and_evaluate", key="alias")
    prev = get_version_by_alias(model_name, alias)

    try:
        version = register_model(run_id, model_name, alias)
        ti.xcom_push(key="version", value=version)
        send_slack_alert(f"âœ… ë“±ë¡ ì™„ë£Œ: {model_name} v{version} â†’ @{alias} (run_id={run_id})")
    except Exception as e:
        msg = f"âŒ ë“±ë¡ ì‹¤íŒ¨: {e}"
        if prev:
            rollback_model(model_name, prev, alias)
            msg += f" â†’ ë¡¤ë°± v{prev}"
        else:
            msg += " â†’ ë¡¤ë°± ìƒëµ"
        send_slack_alert(msg)
        raise

def sensor_ready_func(ti, **_):
    model_name = ti.xcom_pull(task_ids="train_and_evaluate", key="model_name")
    version = ti.xcom_pull(task_ids="register_model", key="version")
    return check_model_ready(model_name, version)

def trigger_reload_task(ti, **_):
    alias = ti.xcom_pull(task_ids="train_and_evaluate", key="alias")
    try:
        resp = trigger_reload(alias)  # {"status":"success", ...} ê¸°ëŒ€
        send_slack_alert(f"ğŸ” í•«ìŠ¤ì™‘ ì™„ë£Œ: @{alias} â†’ {resp}")
    except Exception as e:
        send_slack_alert(f"âŒ í•«ìŠ¤ì™‘ ì‹¤íŒ¨: {e}")
        raise

def notify_failure():
    send_slack_alert("âš ï¸ ê¸°ì¤€ ë¯¸ë‹¬ â†’ ë“±ë¡/í•«ìŠ¤ì™‘ ìƒëµ")

with DAG(
    dag_id="ml_train_register_and_reload",
    default_args=default_args,
    schedule=None,
    catchup=False,
    tags=["mlops", "train", "sensor", "reload"],
    on_failure_callback=alert_slack,
) as dag:
    train = PythonOperator(task_id="train_and_evaluate", python_callable=train_and_evaluate)
    branch = BranchPythonOperator(task_id="check_result", python_callable=check_result)
    register = PythonOperator(task_id="register_model", python_callable=register_model_task)
    sensor = PythonSensor(task_id="check_model_ready", python_callable=sensor_ready_func, poke_interval=10, timeout=180, mode="reschedule")
    reload = PythonOperator(task_id="trigger_reload", python_callable=trigger_reload_task, trigger_rule=TriggerRule.ALL_SUCCESS)
    failure = PythonOperator(task_id="notify_failure", python_callable=notify_failure, trigger_rule=TriggerRule.NONE_FAILED_MIN_ONE_SUCCESS)

    train >> branch
    branch >> [register, failure]
    register >> sensor >> reload
```

---

## 4ï¸âƒ£ Airflow â†’ FastAPI í˜¸ì¶œ (Ingress ê²½ìœ )

```python
# ml_code/trigger_reload.py
import os, requests
from airflow.models import Variable

def trigger_reload(alias: str):
    base = (
        os.getenv("FASTAPI_RELOAD_URL")
        or os.getenv("FASTAPI_BASE_URL")
        or Variable.get("FASTAPI_RELOAD_URL", default_var=None)
        or Variable.get("FASTAPI_BASE_URL")
    )
    token = os.getenv("RELOAD_SECRET_TOKEN") or Variable.get("RELOAD_SECRET_TOKEN")
    url = f"{base}/variant/{alias}/reload"

    # self-signed í™˜ê²½ì´ë©´ ì‹ ë¢° ë£¨íŠ¸ êµ¬ì„± ë˜ëŠ” verify=False
    verify = not url.startswith("https://") or os.getenv("ALLOW_SELF_SIGNED") != "true"

    r = requests.post(url, headers={"x-token": token}, timeout=10, verify=verify)
    r.raise_for_status()
    data = r.json()
    if data.get("status") != "success":
        raise RuntimeError(f"Reload failed: {data}")
    return {"alias": alias, "version": data.get("version"), "run_id": data.get("run_id")}
```

---

## 5ï¸âƒ£ Helm/ê°’ ìš”ì•½ (dev/prod)

### â–¶ FastAPI (env)

- `MLFLOW_TRACKING_URI`:
    - dev: `http://mlflow-dev-service.mlflow-dev.svc.cluster.local:5000`
    - prod: `http://mlflow-prod-service.mlflow-prod.svc.cluster.local:5000`
- `MODEL_NAME=best_model`
- `ALIAS_SELECTION_MODE` / `DEFAULT_ALIAS` / `CANARY_PERCENT`
- `envFrom`: `aws-credentials-secret`, `fastapi-token-*-secret`, `slack-webhook-*-secret`

### â–¶ Airflow (env/variables)

- `FASTAPI_RELOAD_URL`
    - dev: `https://fastapi.local`
    - prod: `https://fastapi.prod`
- `AIRFLOW__WEBSERVER__WEB_SERVER_BASE_URL`
    - dev: `http://airflow.local`
    - prod: `http://airflow.prod`
- `MLFLOW_TRACKING_URI`
    - dev: `http://mlflow-dev-service.mlflow-dev.svc.cluster.local:5000`
    - prod: `http://mlflow-prod-service.mlflow-prod.svc.cluster.local:5000`
- Airflow Variables:
    
    `model_name`, `mlflow_alias`, `logreg_C`, `logreg_max_iter`, `accuracy_threshold`
    

---

## 6ï¸âƒ£ Slack ì•Œë¦¼ í‘œì¤€

| êµ¬ë¶„ | ë°œìƒ ì‹œì  | ë©”ì‹œì§€ í•„ë“œ(ì˜ˆì‹œ) |
| --- | --- | --- |
| í•™ìŠµ ê¸°ì¤€ ë¯¸ë‹¬ | `notify_failure` | `acc`, `threshold` |
| ë“±ë¡ ì„±ê³µ/ì‹¤íŒ¨ | `register_model_task` | `model`, `version`, `@alias`, `run_id`, (ì‹¤íŒ¨ ì‹œ ë¡¤ë°±) |
| ì„¼ì„œ | `check_model_ready` | `status` (READY/FAILED_REGISTRATION) |
| í•«ìŠ¤ì™‘ | `trigger_reload` & FastAPI | `alias`, `version`, `run_id` |
| ì „ì—­ ì‹¤íŒ¨ | `on_failure_callback` | `dag_id`, `task_id`, `log_url` |

---

## 7ï¸âƒ£ ê²€ì¦ ëª…ë ¹

```bash
# Ingress(í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸/TLS/host)
kubectl -n fastapi-dev get ing -o yaml | egrep 'ingressClassName|whitelist-source-range|host:'

# Airflow â†’ FastAPI í˜¸ì¶œ í™˜ê²½
NS=airflow-dev
POD=$(kubectl -n $NS get po -l component=scheduler -o name | head -1)
kubectl -n $NS exec $POD -- printenv | egrep 'FASTAPI_RELOAD_URL|RELOAD_SECRET_TOKEN|AIRFLOW__WEBSERVER__WEB_SERVER_BASE_URL'

# í•«ìŠ¤ì™‘ í˜¸ì¶œ
curl -sk -X POST https://fastapi.local/variant/B/reload -H "x-token: <RELOAD_SECRET_TOKEN>"
```

---

## ğŸ ì •ë¦¬

> /reload ë³´ì•ˆ 3ì¢… + DAG ìë™í™”ê°€ í•˜ë‚˜ì˜ í‘œì¤€ í”Œë¡œìš°ë¡œ ì •ì°©ë˜ì—ˆìŠµë‹ˆë‹¤.
> 
> 
> MLflow **Alias**ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ë“±ë¡Â·ê°ì‹œÂ·í•«ìŠ¤ì™‘ì´ ì¼ê´€ë˜ê²Œ ì´ì–´ì§€ë©°, Slackìœ¼ë¡œ ì „ ê³¼ì •ì´ ê°€ì‹œí™”ë©ë‹ˆë‹¤.
>
