+++
date = '2025-08-18T17:11:21+09:00'
draft = false
title = '[MLOps ìš´ì˜ ê³ ë„í™” - 5ë‹¨ê³„: Airflow ì•ˆì •í™” & FastAPI HTTPS ë³´ì•ˆ]'
categories = ['MLOps Pipeline', 'FastAPI', 'MLflow', 'Airflow', 'Kubernetes', 'Helm']
+++

## Airflow ì•ˆì •í™” & FastAPI HTTPS ë³´ì•ˆ ì ìš© (cert-manager ì–´ë…¸í…Œì´ì…˜ ë°˜ì˜ ì™„ë£Œ)

---

## ğŸ§  ì‹œë‚˜ë¦¬ì˜¤ ì„¤ëª…

> â€œëª¨ë¸ì„ ë“±ë¡í•˜ëŠ” ê²ƒë³´ë‹¤ ë” ì¤‘ìš”í•œ ê±´
> 
> 
> **ì–¸ì œ Reloadê°€ ì‹¤í–‰ë˜ëŠëƒ**ì…ë‹ˆë‹¤. ì—¬ê¸°ê°€ ìš´ì˜ ì•ˆì •ì„±ì„ ë‚˜ëˆ„ëŠ” ì§€ì ì´ë‹ˆê¹Œìš”.â€
> 
> â€œê·¸ë˜ì„œ ì´ë²ˆ ë‹¨ê³„ì—ì„œëŠ” Airflow íë¦„ì„ í•œ ë²ˆ ë” ë‹¨ë‹¨íˆ ì¡°ì´ê³ ,
> 
> FastAPI ìª½ì€ HTTPSÂ·í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ê¹Œì§€ ì ìš©í•´
> 
> **â€˜ì•ˆì „í•˜ê²Œ ìë™í™”ëœë‹¤â€™ëŠ” í™•ì‹ ì„ ì£¼ëŠ” êµ¬ì¡°**ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.â€
> 

---

## ğŸ¯ í•µì‹¬ ìš”ì•½

- **Airflow**: `PythonSensor(mode="reschedule")`ë¡œ **READY ê°ì‹œ**, `TriggerRule.ALL_SUCCESS`ë¡œ **ì„±ê³µ ì²´ì¸ì—ì„œë§Œ** `/reload`
- **ë°ì´í„°/ìƒíƒœ ê¼¬ì„ ë°©ì§€**: Variable ê²€ì¦ ìœ í‹¸ + XCom í‚¤ í‘œì¤€
- **FastAPI**: Ingress **TLS(HTTPS) + IP í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸** ê°•í™”
- **cert-manager + ClusterIssuer(self-signed)** ìë™ ë°œê¸‰/ê°±ì‹ : **í…œí”Œë¦¿ì— ì–´ë…¸í…Œì´ì…˜ ìë™ ì£¼ì… ë°˜ì˜ ì™„ë£Œ**

---

## 5-1ï¸âƒ£ Airflow ì•ˆì •í™”: Sensor ë¦¬íŒ©í† ë§ & XCom/Variable í‘œì¤€

### 1) DAG êµ¬ì¡°

```mermaid
flowchart LR
  classDef node fill:#f7f7ff,stroke:#7aa7ff,stroke-width:1px,color:#1e3a8a;

  A["train_and_evaluate<br/>(PythonOperator)"] --> B{"check_result<br/>(Branch)"}
  B -->|acc >= threshold| C["register_model<br/>(PythonOperator)"]
  B -->|acc < threshold| F["notify_failure<br/>(PythonOperator)"]
  C --> D["check_model_ready<br/>(PythonSensor)"]
  D --> E["trigger_reload<br/>(PythonOperator)<br/>TriggerRule.ALL_SUCCESS"]

  class A,B,C,D,E,F node;

```

### 2) READY ê°ì‹œ ì „ìš© ì„¼ì„œ

```python
# dags/ml_code/sensor_model_ready.py
import mlflow
from ml_code.config import get_mlflow_client
from airflow.utils.log.logging_mixin import LoggingMixin

logger = LoggingMixin().log

def check_model_ready(model_name: str, version: str) -> bool:
    client = get_mlflow_client()
    mv = client.get_model_version(name=model_name, version=version)
    logger.info(f"[Sensor] ìƒíƒœ ì²´í¬: {model_name} v{version} â†’ {mv.status}")
    if mv.status == "READY":
        return True
    elif mv.status == "FAILED_REGISTRATION":
        raise RuntimeError("âŒ ëª¨ë¸ ë“±ë¡ ì‹¤íŒ¨: ìƒíƒœ FAILED_REGISTRATION")
    return False
```

### 3) DAG ë³¸ë¬¸(í•µì‹¬ ë°œì·Œ) â€” **ì„±ê³µ ì²´ì¸ ë³´ì¥ & í‘œì¤€í™”ëœ ë³€ìˆ˜/XCom**

```python
# dags/dag_ml_train_register_reload.py
from airflow import DAG
from airflow.operators.python import PythonOperator, BranchPythonOperator
from airflow.sensors.python import PythonSensor
from airflow.utils.trigger_rule import TriggerRule
from airflow.exceptions import AirflowSkipException
from airflow.models import Variable
from datetime import datetime, timedelta
from pendulum import timezone

from ml_code.train_model import train_model
from ml_code.register_model import register_model
from ml_code.rollback_model import rollback_model
from ml_code.trigger_reload import trigger_reload
from ml_code.sensor_model_ready import check_model_ready
from utils.slack_alerts import send_slack_alert, alert_slack
from mlflow.tracking import MlflowClient

kst = timezone("Asia/Seoul")
default_args = {"start_date": datetime(2025, 1, 1, tzinfo=kst), "retries": 1, "retry_delay": timedelta(minutes=2)}

def get_param(key, default, cast_func, validate_func=None):
    try:
        value = cast_func(Variable.get(key, default=str(default)))
        if validate_func and not validate_func(value):
            raise ValueError("Validation failed")
        return value
    except Exception as e:
        send_slack_alert(f"[Param] {key} ë¡œë”© ì‹¤íŒ¨: {e} â†’ ê¸°ë³¸ê°’ {default} ì‚¬ìš©")
        return default

def get_version_by_alias(model_name, alias):
    try:
        return MlflowClient().get_model_version_by_alias(model_name, alias).version
    except Exception:
        return None

def train_and_evaluate(ti, **_):
    C = get_param("logreg_C", 1.0, float, lambda x: 0.001 <= x <= 10.0)
    max_iter = get_param("logreg_max_iter", 200, int, lambda x: x > 50)
    threshold = get_param("accuracy_threshold", 0.9, float, lambda x: 0.5 <= x <= 0.99)
    model_name = Variable.get("model_name")
    alias = Variable.get("mlflow_alias")
    if not (model_name and alias):
        raise ValueError("í•„ìˆ˜ Variable ëˆ„ë½: model_name ë˜ëŠ” mlflow_alias")
    acc, run_id = train_model(C=C, max_iter=max_iter)
    if not run_id:
        raise ValueError("run_id ì—†ìŒ â†’ í•™ìŠµ ì‹¤íŒ¨")
    for k, v in {"run_id": run_id, "model_name": model_name, "alias": alias, "acc": acc, "threshold": threshold}.items():
        ti.xcom_push(key=k, value=v)

def check_result(ti, **_):
    acc = ti.xcom_pull(task_ids="train_and_evaluate", key="acc")
    thr = ti.xcom_pull(task_ids="train_and_evaluate", key="threshold")
    if acc is None or thr is None:
        send_slack_alert("âŒ check_result â†’ XCom ëˆ„ë½")
        raise AirflowSkipException()
    return "register_model" if acc >= thr else "notify_failure"

def register_model_task(ti, **_):
    run_id = ti.xcom_pull(task_ids="train_and_evaluate", key="run_id")
    model_name = ti.xcom_pull(task_ids="train_and_evaluate", key="model_name")
    alias = ti.xcom_pull(task_ids="train_and_evaluate", key="alias")
    prev_version = get_version_by_alias(model_name, alias)
    try:
        version = register_model(run_id, model_name, alias)
        ti.xcom_push(key="version", value=version)
        send_slack_alert(f"âœ… ëª¨ë¸ ë“±ë¡ ì™„ë£Œ: {model_name} v{version} â†’ @{alias}")
    except Exception as e:
        msg = f"âŒ ëª¨ë¸ ë“±ë¡ ì‹¤íŒ¨: {e}"
        if prev_version:
            rollback_model(model_name, prev_version, alias)
            msg += f" â†’ ë¡¤ë°± ì™„ë£Œ: v{prev_version}"
        else:
            msg += " â†’ ë¡¤ë°± ìƒëµ"
        send_slack_alert(msg)
        raise

def sensor_ready_func(ti, **_):
    model_name = ti.xcom_pull(task_ids="train_and_evaluate", key="model_name")
    version = ti.xcom_pull(task_ids="register_model", key="version")
    return check_model_ready(model_name, version)

def trigger_reload_task(ti, **_):
    alias = ti.xcom_pull(task_ids="train_and_evaluate", key="alias")
    try:
        trigger_reload(alias)  # FastAPI ì‘ë‹µ {"status":"success", ...} ê¸°ëŒ€
        send_slack_alert(f"ğŸ” í•«ìŠ¤ì™‘ ì™„ë£Œ: @{alias}")
    except Exception as e:
        send_slack_alert(f"âŒ í•«ìŠ¤ì™‘ ì‹¤íŒ¨: {e}")
        raise

def notify_failure():
    send_slack_alert("âš ï¸ ê¸°ì¤€ ë¯¸ë‹¬ â†’ ë“±ë¡ ë° í•«ìŠ¤ì™‘ ìƒëµ")

with DAG(
    dag_id="ml_train_register_and_reload",
    default_args=default_args,
    schedule=None,
    catchup=False,
    tags=["mlops", "train", "sensor", "reload"],
    on_failure_callback=alert_slack,
) as dag:
    train = PythonOperator(task_id="train_and_evaluate", python_callable=train_and_evaluate)
    branch = BranchPythonOperator(task_id="check_result", python_callable=check_result)
    register = PythonOperator(task_id="register_model", python_callable=register_model_task)
    sensor = PythonSensor(task_id="check_model_ready", python_callable=sensor_ready_func,
                          poke_interval=10, timeout=180, mode="reschedule")
    reload = PythonOperator(task_id="trigger_reload", python_callable=trigger_reload_task,
                            trigger_rule=TriggerRule.ALL_SUCCESS)  # âœ… ì„±ê³µ ì²´ì¸ì—ì„œë§Œ ì‹¤í–‰
    failure = PythonOperator(task_id="notify_failure", python_callable=notify_failure,
                             trigger_rule=TriggerRule.NONE_FAILED_MIN_ONE_SUCCESS)

    train >> branch
    branch >> [register, failure]
    register >> sensor >> reload

```

**ìš´ì˜ í¬ì¸íŠ¸**

- ì„¼ì„œëŠ” **reschedule**ë¡œ ì›Œì»¤ ìŠ¬ë¡¯ ì ì‹ ë°©ì§€
- `/reload`ëŠ” **ë“±ë¡ + READY ì„¼ì„œ** ëª¨ë‘ ì„±ê³µí•´ì•¼ë§Œ ì‹¤í–‰
- Variable ìºìŠ¤íŒ…/ê²€ì¦ ì‹¤íŒ¨ëŠ” **Slack í†µì§€ + ì•ˆì „ ê¸°ë³¸ê°’**ìœ¼ë¡œ ì§„í–‰
- XCom í‚¤ëª…: `run_id / model_name / alias / acc / threshold / version` ê³ ì •

---

## 5-2ï¸âƒ£ FastAPI HTTPS & cert-manager ìë™ ë°œê¸‰ (ì–´ë…¸í…Œì´ì…˜ ìë™ ì£¼ì… ë°˜ì˜ ì™„ë£Œ)

### 1) êµ¬ì¡°

```mermaid
flowchart LR
  subgraph Cluster["Kubernetes"]
    subgraph cert["cert-manager"]
      I["ClusterIssuer(selfsigned-issuer)"]
      C["Certificate (fastapi-*-tls)"]
    end
    N["Nginx Ingress Controller (TLS termination)"]
    S["Service (fastapi-*-service)"]
    D["Deployment (FastAPI, HTTP backend)"]
  end

  I --> C --> N --> S --> D

```

> TLSëŠ” Ingressì—ì„œ ì¢…ë‹¨(ë³µí˜¸í™”)ë˜ê³ , ë°±ì—”ë“œëŠ” HTTPë¡œ ìœ ì§€í•©ë‹ˆë‹¤.
> 
> 
> ì¸ì¦ì„œ ë°œê¸‰Â·ê°±ì‹ ì€ cert-managerê°€ **ClusterIssuer(self-signed)** ë¥¼ í†µí•´ ìë™ ì²˜ë¦¬í•©ë‹ˆë‹¤.
> 

### 2) Values(dev/prod) â€” ì‹¤í™˜ê²½ ê°’ê³¼ ì¼ì¹˜

```yaml
# charts/fastapi/values/dev.yaml (ë°œì·Œ)
ingresses:
  - name: fastapi-local
    host: fastapi.local
    className: nginx
    whitelist: 192.168.18.0/24
    paths:
      - path: /
        pathType: Prefix
    tls:
      enabled: true
      secretName: fastapi-dev-tls
      issuerName: selfsigned-issuer
```

```yaml
# charts/fastapi/values/prod.yaml (ë°œì·Œ)
ingresses:
  - name: fastapi-prod
    host: fastapi.prod
    className: nginx
    whitelist: 192.168.18.0/24
    paths:
      - path: /
        pathType: Prefix
    tls:
      enabled: true
      secretName: fastapi-prod-tls
      issuerName: selfsigned-issuer
```

### 3) Ingress í…œí”Œë¦¿ â€” **ì–´ë…¸í…Œì´ì…˜ ìë™ ì£¼ì…**

> tls.issuerNameì´ ì„¤ì •ë˜ë©´ cert-manager ì–´ë…¸í…Œì´ì…˜ì´ ìë™ìœ¼ë¡œ ì£¼ì…ë©ë‹ˆë‹¤.
> 

```yaml
# charts/fastapi/templates/fastapi-ingress.yaml (í•µì‹¬ë¶€)
{{- range .Values.ingresses }}
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ $.Release.Name }}-{{ .name }}
  annotations:
    nginx.ingress.kubernetes.io/whitelist-source-range: "{{ .whitelist }}"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
{{- if and .tls .tls.enabled .tls.issuerName }}
    cert-manager.io/cluster-issuer: "{{ .tls.issuerName }}"
{{- end }}
spec:
  ingressClassName: {{ $.className | default "nginx"}}
  rules:
    - host: {{ .host }}
      http:
        paths:
{{- range .paths }}
          - path: {{ .path }}
            pathType: {{ .pathType }}
            backend:
              service:
                name: {{ $.Values.service.name }}
                port:
                  number: {{ $.Values.service.port }}
{{- end }}
{{- if and .tls .tls.enabled }}
  tls:
    - hosts:
        - {{ .host }}
      secretName: {{ .tls.secretName }}
{{- end }}
{{- end }}
```

### 4) ClusterIssuer (ê³µí†µ 1íšŒ)

```yaml
# one-time
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: selfsigned-issuer
spec:
  selfSigned: {}
```

### 5) ê²€ì¦

```bash
# ë¦¬ì†ŒìŠ¤ í™•ì¸
kubectl get clusterissuer
kubectl -n fastapi-dev get certificate
kubectl -n fastapi-dev get secret | grep fastapi-dev-tls

# Ingressì— ì–´ë…¸í…Œì´ì…˜ ë°˜ì˜ ì—¬ë¶€
kubectl -n fastapi-dev get ing -o yaml | grep -A3 annotations:

# HTTPS ì‘ë‹µ(ë¡œì»¬/í…ŒìŠ¤íŠ¸)
curl -vkI https://fastapi.local --resolve fastapi.local:443:<LB_IP>
```

**ì •ìƒ ì§€í‘œ**

- `SSL certificate verify ok`(self-signedëŠ” ë¡œì»¬ ì‹ ë¢° ì´ìŠˆë¡œ ê²½ê³  ê°€ëŠ¥)
- ì‘ë‹µ í—¤ë” `server: nginx`, Ingress ë ˆë²¨ì—ì„œ 200/404 ì‘ë‹µ

---

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ]  Airflow `PythonSensor(mode="reschedule")` ì ìš©
- [ ]  `/trigger_reload`ëŠ” `TriggerRule.ALL_SUCCESS`ë¡œ **ì„±ê³µ ì²´ì¸ ì „ìš©**
- [ ]  `get_param()` ìœ í‹¸ë¡œ Variable **ê²€ì¦/ìºìŠ¤íŒ…/Slack í†µì§€**
- [ ]  XCom í‚¤ í‘œì¤€: `run_id / model_name / alias / acc / threshold / version`
- [ ]  **Ingress í…œí”Œë¦¿ì— cert-manager ì–´ë…¸í…Œì´ì…˜ ìë™ ì£¼ì…(ë°˜ì˜ ì™„ë£Œ)**
- [ ]  dev/prod ë³„ **host / secretName / whitelist / issuerName** ê°’ ì¼ì¹˜ í™•ì¸

---

## ğŸ§© íŒ

| ì¦ìƒ | ì›ì¸ | í•´ê²° |
| --- | --- | --- |
| Sensor íƒ€ì„ì•„ì›ƒ | READY ë¯¸ë„ë‹¬ | ëª¨ë¸ ë“±ë¡ ì‹¤íŒ¨ ë¡œê·¸ í™•ì¸, íŒŒë¼ë¯¸í„°/ë°ì´í„° ì¬ì ê²€ |
| Reloadê°€ ë¨¼ì € ì‹¤í–‰ | TriggerRule ëˆ„ë½ | `/trigger_reload`ë¥¼ `ALL_SUCCESS`ë¡œ ê³ ì • |
| ì¸ì¦ì„œ Pending | cert-manager ì´ë²¤íŠ¸ ì˜¤ë¥˜ | `kubectl describe certificate`ë¡œ ì›ì¸ í™•ì¸, 
Issuer/ì–´ë…¸í…Œì´ì…˜ ì¬ê²€ |
| SAN ë¶ˆì¼ì¹˜ ê²½ê³  | host ë³€ê²½ ì”ì¡´ | í•´ë‹¹ `Certificate` ì‚­ì œ â†’ cert-manager ìë™ ì¬ë°œê¸‰ |
| 403 ì ‘ê·¼ ê±°ë¶€ | í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ë¶ˆì¼ì¹˜ | `nginx.ingress.kubernetes.io/whitelist-source-range` ëŒ€ì—­ í™•ì¸ |

---

## ğŸ ì •ë¦¬

> AirflowëŠ” Sensor + ì„±ê³µ ì²´ì¸ íŠ¸ë¦¬ê±°ë¡œ ì‹ ë¢°ë„ë¥¼ ëŒì–´ì˜¬ë¦¬ê³ ,
> 
> 
> FastAPIëŠ” **Ingress TLS + í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸**ì— **cert-manager ìë™ ë°œê¸‰**ê¹Œì§€ ë”í•´ ìš´ì˜ ë³´ì•ˆì„ ë‹¨ë‹¨íˆ í–ˆìŠµë‹ˆë‹¤.
> 
> ì´ì œ â€œ**ë“±ë¡ â†’ READY â†’ Reload**â€ê°€ **ì •ìƒ ì¼€ì´ìŠ¤ì—ì„œë§Œ** ë°˜ì˜ë˜ëŠ” **ì•ˆì • ë£¨í”„**ê°€ ì™„ì„±
>
